1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?</br>
Unary RPC melibatkan suatu request dari klien dan satu respons dari server. Unary RPC sesuai untuk digunakan pada interaksi request-response sederhana di mana tidak ada streaming yang diperlukan.</br>
Server Streaming RPC melibatkan satu request dari klien dan stream respons dari server. Server Streaming RPC cocok untuk digunakan pada skenario di mana klien perlu menerima jumlah data yang besar dari server tanpa mengirim request tambahan.</br>
Bidirectional Streaming melibatkan receiver stream dari klien dan response stream dari server. Bidirectional Streaming cocok digunakan pada skenario di mana ada kebutuhan untuk komunikasi dua arah antara klien dan server, seperti aplikasi obrolan real-time atau feed data langsung.

2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?</br>
Dalam mengimplementasikan layanan gRPC di Rust, perhatian keamanan terhadap otentikasi, otorisasi, dan enkripsi data sangat penting. Otentikasi memastikan akses yang sah pada aplikasi. Di sisi lain, otorisasi berfungsi untukmengatur akses sesuai peran. Sedangkan enkripsi data menjaga kerahasiaan dan integritas informasi. Dengan langkah-langkah ini, kepatuhan terhadap standar keamanan dapat terjaga.

3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?</br>
Tantangan pada bidirectional streaming dalam Rust gRPC terdiri dari beberapa hal. Salah satunya adalah manajemen multiple stream secara bersamaan, di mana kita perlu mengatur stream masuk dan keluar secara efisien. Selain itu, penanganan kesalahan dan waktu habis harus dilakukan dengan baik untuk memastikan koneksi tetap stabil. Sinkronisasi antara klien dan server juga menjadi perhatian penting, terutama dalam situasi di mana pesan harus diproses secara real-time agar klien dan server selalu memiliki informasi yang akurat dan terbaru.

4. What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?</br>
Penggunaan ReceiverStream pada Streaming Responses: tokio_stream::wrappers::ReceiverStream menyediakan cara yang mudah untuk mengonversi tokio::sync::mpsc::Receiver menjadi stream. Keuntungan termasuk kemudahan penggunaan dan integrasi dengan waktu eksekusi asinkronus Tokio. Namun, kita juga perlu untuk mempertimbangkan masalah backpressure dan manajemen memori yang mungkin terjadi ketika menggunakan streaming dalam layanan Rust gRPC.

5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?</br>
Untuk meningkatkan kemudahan pemeliharaan dan perluasan kode di Rust gRPC, struktur kode dapat dibuat dengan menggunakan konsep modul dan traits. Dengan membagi fungsi-fungsi terkait ke dalam modul yang terpisah, dan mendefinisikan perilaku umum menggunakan traits, memungkinkan untuk penggunaan kembali kode yang efisien dan promosi modularitas. Hal ini juga memfasilitasi perluasan fitur di masa mendatang, karena memisahkan fungsionalitas ke dalam komponen yang terpisah mempermudah refaktorisasi dan penambahan fitur baru tanpa mengganggu keseluruhan sistem.

6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?</br>
Langkah-langkah tambahan untuk menangani logika pemrosesan pembayaran yang lebih kompleks adalah validasi request pembayaran, integrasi dengan gateway pembayaran eksternal atau API, dan error handling untuk edge case seperti kegagalan jaringan.

7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?</br>
Penggunaan gRPC sebagai protokol komunikasi dalam arsitektur dan desain sistem terdistribusi memiliki dampak yang signifikan. Dengan gRPC, sistem dapat memanfaatkan komunikasi yang efisien dan berkinerja tinggi antara layanan, memfasilitasi pengembangan aplikasi yang skalabel. Selain itu, gRPC mendukung berbagai bahasa pemrograman dan platform, memungkinkan pekerjaan yang lebih baik dengan teknologi dan platform lain. Hal ini memungkinkan pengembang untuk membangun sistem yang lebih fleksibel dan mudah terintegrasi dengan sistem lain.

8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?</br>
Kelebihan menggunakan HTTP/2, protokol dasar untuk gRPC, dibandingkan dengan HTTP/1.1 atau HTTP/1.1 dengan WebSocket untuk REST API, antara lain adalah peningkatan kinerja yang signifikan, request multiplexing melalui satu koneksi tunggal, dan dukungan untuk bidirectional streaming. Namun, HTTP/2 juga dapat meningkatkan kompleksitas implementasi dan memerlukan dukungan server dan klien yang sesuai. Apabila server belum support HTTP/2 maka HTTP/2 tidak dapat digunakan. Hal ini juga berlaku pada server. Di sisi lain, HTTP/1.1 dengan WebSocket untuk REST API mungkin lebih mudah diimplementasikan dan memiliki dukungan yang lebih luas, tetapi mungkin tidak seefisien HTTP/2 dalam hal kinerja dan kemampuan streaming.

9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?</br>
Model request-response dari REST API berbeda dengan kemampuan bidirectional streaming dari gRPC dalam konteks komunikasi real-time dan responsif. REST API biasanya menggunakan model request-response yang bersifat sinkron, di mana klien mengirim request dan menunggu respons dari server sebelum melanjutkan operasi selanjutnya. Di sisi lain, gRPC memungkinkan komunikasi asinkron dan bidirectional streaming antara klien dan server. Hal ini memungkinkan klien dan server untuk saling berinteraksi secara real-time, dengan kemampuan untuk mengirimkan dan menerima data secara langsung tanpa harus menunggu respons sebelumnya. Dengan demikian, gRPC lebih responsif dan cocok untuk aplikasi yang membutuhkan komunikasi real-time dan interaktif.

10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?</br>
Pendekatan berbasis skema dari gRPC menggunakan Protocol Buffers memiliki implikasi yang berbeda dibandingkan dengan sifat yang lebih fleksibel dan tanpa skema dari JSON yang terdapat pada REST API. Dengan Protocol Buffers, definisi skema yang ketat diperlukan sebelum data dapat diserialisasi dan didecrypt. Hal ini memberikan tingkat keamanan dan efisiensi yang lebih baik. Namun, hal ini juga memiliki keterbatasan pada fleksibilitas struktur data dan memerlukan langkah-langkah tambahan untuk mengubah skema. Di sisi lain, JSON dalam REST API lebih mudah diakses dan dipahami. Meskipun demikian, JSON tidak menyediakan keamanan yang sama dan sering kali memerlukan validasi data tersendiri.